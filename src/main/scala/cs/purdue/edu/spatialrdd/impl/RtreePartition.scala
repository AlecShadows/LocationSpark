package cs.purdue.edu.spatialrdd.impl

import cs.purdue.edu.spatialindex.rtree._
import cs.purdue.edu.spatialrdd.SpatialRDDPartition
import cs.purdue.edu.spatialrdd.PointSerializer

import org.apache.spark.Logging


/**
 * the key is the location, and value is the related data like text
 */

import scala.reflect.ClassTag

/**
 * Created by merlin on 8/4/15.
 */

class RtreePartition[K, V]
(protected val tree: RTree[V])
(override implicit val kTag: ClassTag[K],
 override implicit val vTag: ClassTag[V],
 implicit val kSer: PointSerializer[K,V])
  extends SpatialRDDPartition[K,V] with Logging
{

  override def size: Long = tree.size.asInstanceOf[Long]

  override def apply(k: K): V = tree.searchPoint(kSer.toPoint(k)).asInstanceOf[V]

  def isDefined(k: K): Boolean = tree.searchPoint(kSer.toPoint(k)) != null

  override def iterator: Iterator[(K, V)] ={

    this.tree.entries.map(
      kvs=>(kvs.geom.asInstanceOf[K],kvs.value)
    )

  }

  /**
   * constructor for a new rtree partition
   */
  protected def withMap(map: RTree[V]): RtreePartition[K, V] = {

    new RtreePartition(map)

  }

  /**
   * Gets the values corresponding to the specified keys, if any. those keys can be the two dimensional object
   */
  override def multiget(ks: Iterator[K]): Iterator[(K, V)]=
  {

    ks.flatMap { k => Option(this(k)).map(v => (k, v)) }

  }


  override def delete(ks: Iterator[K]): SpatialRDDPartition[K, V]=
  {
    var newMap = this.tree

    val km=ks.map {
      case(k) =>
        kSer.toEntry(k)
    }.toIterable

    newMap=newMap.removeAll(km)

    this.withMap(newMap)
  }


  /**
   * Updates the keys in `kvs` to their corresponding values generated by running `f` on old and new
   * values, if an old value exists, or `z` otherwise. Returns a new IndexedRDDPartition that
   * reflects the modification.
   */
  override def multiput[U](kvs: Iterator[(K, U)], z: (K, U) => V, f: (K, V, U) => V): SpatialRDDPartition[K, V] =
  {

    var newMap = this.tree

    for (ku <- kvs)
    {
      val oldpoint=kSer.toPoint(ku._1)

      val oldV = newMap.searchPoint(oldpoint)

      val newV = if (oldV == null) z(ku._1, ku._2) else f(ku._1, oldV.asInstanceOf[V], ku._2)

      val newEntry=kSer.toEntry(ku._1, newV)

      newMap=newMap.insert(oldpoint, newV)

    }

    this.withMap(newMap)
  }

  /**
   *remove tuples do not meet the predicate condition
   */
  def filter(pred: (K, V) => Boolean): SpatialRDDPartition[K, V]=
  {
    var newMap = this.tree

    this.withMap(newMap)
  }

  /*def createUsingIndex[V2: ClassTag](elems: Iterator[(K, V2)])(implicit kSer: PointSerializer[K,V]): SpatialRDDPartition[K, V2]=
  {
    //val map = RTree(elems.flatMap{ (k, v) => kSer.toEntry(k,v)})

    //new RtreePartition(map)

    var newMap = this.tree

    this.withMap(newMap)

  }*/

}

private[spatialrdd] object RtreePartition {

  def apply[K: ClassTag, V: ClassTag]
  (iter: Iterator[(K, V)])(implicit kSer: PointSerializer[K,V]) =
    apply[K, V, V](iter, (id, a) => a, (id, a, b) => b)


  def apply[K: ClassTag, U: ClassTag, V: ClassTag]
  (iter: Iterator[(K, V)], z: (K, U) => V, f: (K, V, U) => V)
  (implicit kSer: PointSerializer[K,V]):
  SpatialRDDPartition[K, V] =
  {
    val map = RTree(iter.map{ case(k, v) => kSer.toEntry(k,v)})

    new RtreePartition(map)

  }

}